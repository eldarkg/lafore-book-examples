// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 11chapter_07exercise.cpp
// Задана программа из примера 457_parse.cpp 10-й главы, в которой созданы классы
// Stack (представляет стек) и express (представляет арифметическое выражение) для
// вычисления арифметических выражений, составленных из одноцифровых чисел.
//
// Планируем улучшить эту программу так, чтобы она могла работать с арифметическими
// выражениями, составленными из вещественных чисел. В этом упражнении сделаем
// первый шаг в этом направлении — требуется переписать класс Stack так, чтобы
// в нем можно было хранить объекты-токены двух видов: «вещественное число» и
// «арифметическая операция».
//
// Для этого следует использовать описанную в задании к упражнению схему классов:
// Token (абстрактный базовый класс), Number (представляет вещественное число),
// Operator (представляет операцию в арифметическом выражении).
//
// И, наконец, требуется написать в main программу для тестирования переписанного
// класса Stack. В ней следует помещать в стек и извлекать из стека объекты-токены
// обоих видов.

////// Пояснение к примеру 457_parse.cpp 10-й главы ////////////////////////////
// программа разбора (парсинга) арифметических выражений
// (вычисляет арифметические выражения, составленные из одноцифровых чисел;
// возможные знаки операций: *, /, +, -)
////////////////////////////////////////////////////////////////////////////////

#include <locale>
#include <iostream>
// #include <cstring> // для работы с функциями вроде wcslen и т.п. не понадобился
using namespace std;

class Token // абстрактный базовый класс
            // (token — по-русски тоже «токен» — объект, выделяемый из строки с
            // арифметическим выражением в процессе ее анализа (парсинга);
            // у нас будут два вида токенов — вещественное число и арифметическая
            // операция)
{
public:
	virtual float getNumber() const = 0;     // чистые виртуальные функции
	virtual wchar_t getOperator() const = 0;
};

class Operator : public Token // класс, представляющий токен «арифметическая операция»
{
private:
	wchar_t oper; // знак арифметической операции (возможные значения: +, –, *, /)
public:
	Operator(wchar_t op) : oper(op) // конструктор с одним аргументом
		{ }
	wchar_t getOperator() const     // метод выдает знак операции
		{ return oper; }
	float getNumber() const // фиктивная функция (нужна только, чтобы данный класс
		{ return 0.0f; }    // не стал абстрактным, для объектов данного класса
	                        // не должна вызываться)
};

class Number : public Token // класс, представляющий токен «вещественное число»
{
private:
	float fnum; // вещественное число
public:
	Number(float n) : fnum(n)       // конструктор с одним аргументом
		{ }
	float getNumber() const         // метод выдает значение вещественного числа
		{ return fnum; }
	wchar_t getOperator() const // фиктивная функция (нужна только, чтобы данный класс
		{ return L'0'; }        // не стал абстрактным, для объектов данного класса
	                            // не должна вызываться)
};

class Stack // класс, реализующий стек
{
private:
	Token* atoken[100]; // стек в виде массива указателей на токены
	                    // (может содержать переменные типов Operator* и Number*)
	int top;            // индекс, указывающий на вершину стека
public:
	Stack()                // конструктор без аргументов
		{ top = 0; }
	void push(Token* var)  // поместить токен в стек
		{ atoken[++top] = var; }
	Token* pop()           // забрать токен из стека
		{ return atoken[top--]; }
	int gettop() const     // получить индекс, указывающий на вершину стека
		{ return top; }
	bool isNumber() const  // метод определяет, является ли токен на вершине стека
	{                      // вещественным числом (работает, только если стек не пуст)
		                   // (возможность RTTI в компиляторе должна быть включена)
		Number* pNum;
		if (pNum = dynamic_cast<Number*>(atoken[top]))
			return true;
		else
			return false;
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	Stack s; // создадим стек

	// создадим объекты-токены обоих видов
	Number n1(6.02f), n2(3.333f), n3(75.25f), n4(2.0f), n5(3.14159f);
	Operator plus(L'+'), mult(L'*'), minus(L'-'), div(L'/');

	// вперемешку поместим в стек адреса объектов-токенов обоих видов
	s.push(&n1); s.push(&plus); s.push(&n2);
	s.push(&mult); s.push(&n3); s.push(&plus);
	s.push(&n4); s.push(&div); s.push(&n5);

	while (s.gettop() > 0) // пока стек не пуст
	{
		// будем извлекать объекты-токены обоих видов из стека и выводить их на экран

		// в зависимости от вида объекта-токена вызываем определенный метод,
		// возвращающий значение токена для вывода на экран
		if (s.isNumber())
			wcout << s.pop()->getNumber();
		else
			wcout << s.pop()->getOperator();

		// если объект-токен не последний в стеке, вывести пробел для разделения
		// токенов на экране
		if (s.gettop() > 0) wcout << L' ';
	}
	wcout << endl;

	return 0;
}