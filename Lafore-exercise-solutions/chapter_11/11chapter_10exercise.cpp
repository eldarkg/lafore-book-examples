// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 11chapter_10exercise.cpp
// Задана программа из примера 457_parse.cpp 10-й главы, в которой созданы классы
// Stack (представляет стек) и express (представляет арифметическое выражение) для
// вычисления арифметических выражений, составленных из одноцифровых чисел.
//
// Также имеется программа из упражнения 7 этой (11-й) главы, в которой был сделан
// первый шаг к улучшению программы из примера 457_parse.cpp 10-й главы так, чтобы
// программа из примера 457_parse.cpp 10-й главы могла работать с арифметическими
// выражениями, составленными из вещественных чисел. А именно: переписан класс Stack
// так, чтобы в нем можно было хранить объекты-токены двух видов: «вещественное число»
// и «арифметическая операция». Сами эти объекты-токены были представлены классами
// Token (абстрактный базовый класс), Number (представляет вещественное число),
// Operator (представляет операцию в арифметическом выражении).
//
// Требуется в этом упражнении закончить улучшение программы из примера 457_parse.cpp
// 10-й главы, чтобы она могла работать с арифметическими выражениями, составленными
// из вещественных чисел. Для этого следует совместить классы из упражнения 7 этой
// (11-й) главы с алгоритмами из примера 457_parse.cpp 10-й главы. В main следует
// протестировать улучшенную программу.

////// Пояснение к примеру 457_parse.cpp 10-й главы ////////////////////////////
// программа разбора (парсинга) арифметических выражений
// (вычисляет арифметические выражения, составленные из одноцифровых чисел;
// возможные знаки операций: *, /, +, -)
////////////////////////////////////////////////////////////////////////////////

#include <locale>
#include <iostream>
// #include <cstring> // для работы с функциями вроде wcslen и т.п. не понадобился
using namespace std;

const int LEN = 80; // максимальная длина арифметического выражения (в символах)
const int MAX = 40; // размер стека

class Token // абстрактный базовый класс
			// (token — по-русски тоже «токен» — объект, выделяемый из строки с
			// арифметическим выражением в процессе ее анализа (парсинга);
			// у нас будут два вида токенов — вещественное число и арифметическая
			// операция)
{
public:
	virtual float getNumber() const = 0;     // чистые виртуальные функции
	virtual wchar_t getOperator() const = 0;
};

class Operator : public Token // класс, представляющий токен «арифметическая операция»
{
private:
	wchar_t oper; // знак арифметической операции (возможные значения: +, –, *, /)
public:
	Operator(wchar_t op) : oper(op) // конструктор с одним аргументом
		{ }
	wchar_t getOperator() const     // метод выдает знак операции
		{ return oper; }
	float getNumber() const // фиктивная функция (нужна только, чтобы данный класс
		{ return 0.0f; }    // не стал абстрактным, для объектов данного класса
		                    // не должна вызываться)
};

class Number : public Token // класс, представляющий токен «вещественное число»
{
private:
	float fnum; // вещественное число
public:
	Number(float n) : fnum(n)       // конструктор с одним аргументом
		{ }
	float getNumber() const         // метод выдает значение вещественного числа
		{ return fnum; }
	wchar_t getOperator() const // фиктивная функция (нужна только, чтобы данный класс
		{ return L'0'; }        // не стал абстрактным, для объектов данного класса
		                        // не должна вызываться)
};

class Stack // класс, реализующий стек
{
private:
	Token* atoken[MAX]; // стек в виде массива указателей на токены
						// (может содержать переменные типов Operator* и Number*)
	int top;            // индекс, указывающий на вершину стека
public:
	Stack()                // конструктор без аргументов
		{ top = 0; }
	void push(Token* var)  // поместить токен в стек
		{ atoken[++top] = var; }
	Token* pop()           // забрать токен из стека
		{ return atoken[top--]; }
	int gettop() const     // получить индекс, указывающий на вершину стека
		{ return top; }
	bool isNumber() const  // метод определяет, является ли токен на вершине стека
	{                      // вещественным числом (работает, только если стек не пуст)
						   // (возможность RTTI в компиляторе должна быть включена)
		Number* pNum;
		if (pNum = dynamic_cast<Number*>(atoken[top]))
			return true;
		else
			return false;
	}
};

class express // класс, представляющий арифметическое выражение
{
private:
	Stack s;       // стек для анализа арифметического выражения
	wchar_t* pStr; // указатель на заданную строку с арифметическим выражением
	int len;       // длина заданной строки
public:
	express(wchar_t* ptr) // конструктор с одним аргументом
	{
		pStr = ptr;         // запоминаем указатель на заданную строку
		len = wcslen(pStr); // запоминаем длину заданной строки
	}
	void parse();  // разбор (парсинг) заданной строки с арифметическим выражением
	float solve(); // вычисление арифметического выражения, оставшегося в стеке
};

// разбор (парсинг) заданной строки с арифметическим выражением
// (метод разбивает выражение на токены и добавляет их в стек, вычисляя
// добавленное в стек ранее, после чего в стеке остается простое выражение вида 5+4
// или вида 2+3*5, в котором можно произвести вычисления справа налево одним проходом,
// что и будет сделано в методе express::solve)
void express::parse()
{
	wchar_t ch;     // символ из заданной строки с арифметическим выражением
	Token* lastval; // последнее помещенное в стек число (операнд)
	Token* lastop;  // последний помещенный в стек знак операции
	
	float ans;      // для вещественных чисел
	Number* ptrN;   // для указателей на токены-числа
	Operator* ptrO; // для указателей на токены-операции

	// указатель на текущую анализируемую позицию в строке с арифметическим выражением
	// (начинаем анализ с начала этой строки)
	wchar_t* pCurrent = pStr;
	
	while (pCurrent[0]) // пока не достигнут конец анализируемой строки
	{
		// получим символ из текущей анализируемой позиции в строке с арифметическим выражением
		ch = pCurrent[0];
		
		if (ch >= L'0' && ch <= L'9') // если это цифра,
		{
			ans = wcstof(pCurrent, &pCurrent); // получим из строки вещественное число
			                                   // (указатель pCurrent передвигаем на следующий токен)
			ptrN = new Number(ans);            // выделим память под токен-число
			s.push(ptrN);                      // поместим токен в стек
		}
		                              // если это знак арифметической операции
		else if (ch == L'+' || ch == L'-' || ch == L'*' || ch == L'/')
		{
			if (s.gettop() == 1) // если это первый в выражении знак операции,
			{
				ptrO = new Operator(ch); // выделим память под токен-операцию
				s.push(ptrO);            // поместим токен в стек
			}
			else // это не первый в выражении знак операции
			{
				lastval = s.pop(); // получаем предыдущее в анализе число-операнд
				lastop = s.pop();  // получаем предыдущий в анализе знак операции
				// если наш знак операции * или /, а предыдущий был + или -, то
				if ((ch == L'*' || ch == L'/') &&
					(lastop->getOperator() == L'+' || lastop->getOperator() == L'-'))
				{
					s.push(lastop);  // отменяем последние два взятия из стека
					s.push(lastval);
				}
				else // во всех других случаях
				{
					// выполним предыдущую операцию и поместим результат в стек
					switch (lastop->getOperator())
					{
					case L'+':
						ans = s.pop()->getNumber() + lastval->getNumber();
						ptrN = new Number(ans);
						s.push(ptrN);
						break;
					case L'-':
						ans = s.pop()->getNumber() - lastval->getNumber();
						ptrN = new Number(ans);
						s.push(ptrN);
						break;
					case L'*':
						ans = s.pop()->getNumber() * lastval->getNumber();
						ptrN = new Number(ans);
						s.push(ptrN);
						break;
					case L'/':
						ans = s.pop()->getNumber() / lastval->getNumber();
						ptrN = new Number(ans);
						s.push(ptrN);
						break;
					default: wcout << L"\nНеизвестный знак операции\n"; exit(1);
					}
				}
				Operator* ptrO = new Operator(ch); // выделим память под токен-операцию
				s.push(ptrO);                      // поместим токен в стек
			}
			pCurrent++; // указатель pCurrent передвигаем на следующий токен
		}
		else // если символ не является ни вещественным числом, ни знаком операции
			{ wcout << L"\nНеразрешенный символ в арифметическом выражении\n"; exit(1); }
	}
}

// вычисление арифметического выражения, оставшегося в стеке
// (после чего стек остается пустым)
float express::solve()
{
	Token* lastval; // последнее помещенное в стек число (операнд)

	float ans;    // для вещественных чисел
	Number* ptrN; // для указателей на токены-числа

	while (s.gettop() > 1) // пока в стеке не останется результат вычисления
	{                      // нашего арифметического выражения,
		lastval = s.pop(); // получим последнее в анализе число-операнд
		switch (s.pop()->getOperator()) // получим последний в анализе знак операции
		{                  // выполним операцию и поместим результат в стек
		case L'+':
			ans = s.pop()->getNumber() + lastval->getNumber();
			ptrN = new Number(ans);
			s.push(ptrN);
			break;
		case L'-':
			ans = s.pop()->getNumber() - lastval->getNumber();
			ptrN = new Number(ans);
			s.push(ptrN);
			break;
		case L'*':
			ans = s.pop()->getNumber() * lastval->getNumber();
			ptrN = new Number(ans);
			s.push(ptrN);
			break;
		case L'/':
			ans = s.pop()->getNumber() / lastval->getNumber();
			ptrN = new Number(ans);
			s.push(ptrN);
			break;
		default: wcout << L"\nНеизвестный знак операции\n"; exit(1);
		}
	}

	return s.pop()->getNumber(); // в стеке остался результат вычисления выражения,
	                             // забираем его и возвращаем; стек остается пустым
}

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));
	// переключение стандартного потока ввода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	wchar_t ans;         // 'д' или 'н'
	wchar_t string[LEN]; // строка с арифметическим выражением для разбора (парсинга)

	wcout << L"Введите арифметическое выражение, например: 2.5+3.0*4/3.148-2.84"
	         L"\nЧисла могут быть вещественными и состоять из нескольких цифр."
	         L"\nНе используйте пробелы и скобки.\n";

	do {
		wcout << L"\nВведите выражение: "; // получаем строку от пользователя (может содержать пробелы),
		ws(wcin); wcin.get(string, LEN);   // предварительно убрав из потока wcin ведущие пробельные символы
		                                   // (пробелы, переводы строки, табуляция)

		express* eptr = new express(string);  // создаем объект-выражение для разбора

		eptr->parse();                        // выполняем разбор (парсинг) выражения
		                                      // (только на этом этапе выдаем ошибку по поводу
		                                      // пробелов в выражении, а не раньше)

		wcout << L"Результат вычисления выражения: "
		      << eptr->solve();               // получаем результат вычисления

		delete eptr;                          // удаляем объект-выражение

		wcout << L"\nЕще одно выражение (д/н)? "; wcin >> ans;
	} while (ans == L'д');

	return 0;
}