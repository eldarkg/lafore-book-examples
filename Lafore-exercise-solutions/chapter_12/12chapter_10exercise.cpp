// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 12chapter_10exercise.cpp
// Требуется добавить проверку на ошибки ввода в оператор извлечения (>>)
// в упражнение 9 этой (12-й) главы (помним, что в том упражнении этот оператор
// был перегружен для класса fraction (обыкновенная дробь)).

////// Задание к упражнению 9 этой (12-й) главы ////////////////////////////////
// Имеется класс fraction (обыкновенная дробь) из упражнения 7 главы 8 и программа
// в main, реализующая с помощью этого класса калькулятор с четырьмя основными
// арифметическими действиями (сложение, вычитание, умножение и деление). Требуется
// перегрузить операторы вставки (<<) и извлечения (>>) для этого класса.
//
// По идее, перегруженные операторы вставки и извлечения заменяют методы display и
// get класса fraction соответственно. Эти методы можно было бы удалить, но в задании
// этого не требуется, поэтому я их оставил.
////////////////////////////////////////////////////////////////////////////////

#include <locale>
#include <iostream>
using namespace std;

class fraction // класс, представляющий обыкновенную дробь
{
private:
	int num; // числитель
	int den; // знаменатель
public:
	// конструктор без аргументов
	fraction()
		{ }
	// конструктор с двумя аргументами
	fraction(int n, int d) : num(n), den(d)
		{ }
	// метод для получения данных класса от пользователя с клавиатуры
	void get()
	{
		wchar_t slash; // для косой черты
		wcout << L"Введите обыкновенную дробь (в формате числитель/знаменатель): ";
		wcin >> num >> slash >> den;
	}
	// константный метод выводит поля объекта класса на экран
	void display() const
	{
		wcout << L"Результат операции: " << num << L'/' << den << endl;
	}
	// перегрузка операции сложения (+) для сложения двух обыкновенных дробей
	fraction operator+ (fraction f) const
	{
		// создаем временный безымянный объект нашего класса с результатом сложения
		// заданных обыкновенных дробей, применяем к нему сокращение до несократимого вида
		// и возвращаем результат
		return fraction(num * f.den + f.num * den,
		                den * f.den).lowterms();
	}
	// перегрузка операции вычитания (-) для нахождения разности двух обыкновенных дробей
	fraction operator- (fraction f) const
	{
		return fraction(num * f.den - f.num * den,
		                den * f.den).lowterms();
	}
	// перегрузка операции умножения (*) для нахождения произведения двух обыкновенных дробей
	fraction operator* (fraction f) const
	{
		return fraction(num * f.num,
		                den * f.den).lowterms();
	}
	// перегрузка операции деления (/) для нахождения частного от деления
	// одной обыкновенной дроби на другую
	fraction operator/ (fraction f) const
	{
		return fraction(num * f.den,
		                den * f.num).lowterms();
	}
	// перегрузка операции сравнения «равно» (==) для обыкновенных дробей
	bool operator== (fraction f) const
	{
		if ((num == f.num) && (den == f.den))
			return true;
		else
			return false;
	}
	// перегрузка операции сравнения «не равно» (!=) для обыкновенных дробей
	bool operator!= (fraction f) const
	{
		if ((num == f.num) && (den == f.den))
			return false;
		else
			return true;
	}
	// метод (прототип) для сокращения дроби до несократимого вида
	// (возвращение преобразованной дроби добавлено, чтобы можно было использовать
	// этот метод в перегруженных операциях сложения, вычитания, умножения и деления)
	fraction lowterms();
	// перегрузка оператора извлечения
	friend wistream& operator>> (wistream& s, fraction& f); // прототип
	// перегрузка оператора вставки
	friend wostream& operator<< (wostream& s, fraction& f); // прототип
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));
	// переключение стандартного потока ввода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	wchar_t ch;             // для ответа пользователя (д/н)
	fraction fr1, fr2, fr3; // для хранения обыкновенных дробей
	wchar_t oper;           // знак операции

	do {
		wcout << L"Введите первую дробь: "; wcin >> fr1;
		wcout << L"Введите операцию (+, -, *, /): ";
		wcin >> oper;
		wcin.ignore(80, L'\n'); // уберем символ '\n' (или другие лишние символы) из потока,
		                        // оставшийся там после ввода пользователем знака операции
		wcout << L"Введите вторую дробь: "; wcin >> fr2;

		switch (oper)
		{
		case L'+':
			fr3 = fr1 + fr2; wcout << L"Ответ: .................... " << fr3 << endl; break;
		case L'-':
			fr3 = fr1 - fr2; wcout << L"Ответ: .................... " << fr3 << endl; break;
		case L'*':
			fr3 = fr1 * fr2; wcout << L"Ответ: .................... " << fr3 << endl; break;
		case L'/':
			fr3 = fr1 / fr2; wcout << L"Ответ: .................... " << fr3 << endl; break;
		default: wcout << L"Введен неверный знак операции! Попробуйте еще." << endl;
		}

		wcout << L"Продолжить? (д/н) ";
		wcin >> ch;
		wcin.ignore(80, L'\n'); // уберем символ '\n' (или другие лишние символы) из потока,
								// оставшийся там после ввода пользователем символа ch
	} while (ch == L'д'); // выход по 'н'

	return 0;
}

// метод для сокращения дроби до несократимого вида
// (возвращение преобразованной дроби добавлено, чтобы можно было использовать
// этот метод в перегруженных операциях сложения, вычитания, умножения и деления)
fraction fraction::lowterms()
{
	long tnum, tden, // две временные переменные для хранения числителя и знаменателя
		 temp,       // временная переменная для хранения значения при обмене
		 gcd;        // наибольший общий делитель, который нужно найти (greatest common divisor)

	tnum = labs(num); // возьмем значения числителя и знаменателя по модулю
	tden = labs(den); // (заголовочный файл cmath для функции labs не понадобился)
	
	if (tden == 0) // проверка знаменателя на 0
		{ wcout << L"Недопустимый знаменатель!"; exit(1); }
	else if (tnum == 0) // проверка числителя на 0
		{ num = 0; den = 1; return fraction(num, den);	}

	// нахождение наибольшего общего делителя (Алгоритм Евклида)
	while (tnum != 0)
	{
		// добьемся, чтобы числитель был больше
		if (tnum < tden)                               // если числитель меньше знаменателя,
			{ temp = tnum; tnum = tden; tden = temp; } // меняем их местами
		
		tnum = tnum - tden;
	}
	gcd = tden;

	num = num / gcd; // делим числитель и знаменатель на
	den = den / gcd; // полученный наибольший общий делитель

	// (возвращение преобразованной дроби добавлено, чтобы можно было использовать
	// этот метод в перегруженных операциях сложения, вычитания, умножения и деления)
	return fraction(num, den);
}

// перегрузка оператора извлечения
wistream& operator>> (wistream& s, fraction& f)
{
	wchar_t slash; // для косой черты
	while (true)   // бесконечный цикл (выход — с помощью оператора break)
	{
		s.unsetf(ios::skipws); // не пропускать ведущие пробельные символы
		s >> f.num;            // попытка получить числитель
		if (s.good()) // если введенное значение является числом, то
		{
			s.unsetf(ios::skipws); // не пропускать ведущие пробельные символы
			s >> slash;            // попытка получить косую черту
			if (slash == L'/')
			{
				s.unsetf(ios::skipws); // не пропускать ведущие пробельные символы
				s >> f.den;            // попытка получить знаменатель
				if (s.good()) // если введенное значение является числом, то
				{
					if (f.den != 0) // проверка знаменателя на ноль
					{
						s.ignore(80, L'\n'); // удалить лишние символы из потока
						break;               // выйти из цикла
					}
					else
						wcout << L" Ошибка ввода: знаменатель не может быть равен нулю!\n";
				}
				else          // иначе, если введенное значение не является числом
				{
					s.clear();         // очистить биты ошибок
					wcout << L" Ошибка ввода: неправильный знаменатель!\n";
				}
			}
			else
				wcout << L" Ошибка ввода: числитель и знаменатель должна разделять косая черта!\n";
		}
		else          // иначе, если введенное значение не является числом
		{
			s.clear();             // очистить биты ошибок
			wcout << L" Ошибка ввода: неправильный числитель!\n";
		}
		s.ignore(80, L'\n');   // удалить лишние символы из потока
		wcout << L" Введите дробь заново: ";
	}
	return s;
}

// перегрузка оператора вставки
wostream& operator<< (wostream& s, fraction& f)
{
	s << f.num << L'/' << f.den;
	return s;
}