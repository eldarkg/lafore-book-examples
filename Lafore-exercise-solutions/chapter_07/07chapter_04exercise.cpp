// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 07chapter_04exercise.cpp
// программа получает от пользователя целые числа и сохраняет их в массив,
// написать функцию, находящую наибольшее из полученных чисел

#include <locale>
#include <iostream>
using namespace std;

int maxint(int [], int); // прототип функции

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));
	// переключение стандартного потока ввода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	const int SIZE = 100; // размер массива
	int numbers[SIZE];    // сам массив целых чисел
	wchar_t ans;          // для ответа пользователя о продолжении ввода (д/н)
	int n = 0;            // индекс массива при вводе целых чисел
	                      // (количество введенных целых чисел)

	// получаем от пользователя целые числа и помещаем их в массив
	do {
		if (n == SIZE) // при переполнении массива
		{
			wcout << L"Нельзя ввести больше " << SIZE << L" целых чисел!" << endl;
			break; // выйти из цикла
		}
		wcout << L"Введите целое число номер " << n + 1 << L": "; wcin >> numbers[n++];
		wcout << L"Продолжить (д/н)? "; wcin >> ans;
	} while(ans != L'н');

	// находим индекс наибольшего числа (элемента) из введенных в массиве
	int imaxel = maxint(numbers, n);

	// выводим на экран наибольшее из введенных число и его индекс в массиве
	wcout << L"\nНаибольшим из введенных является число " << numbers[imaxel]
		<< L", оно введено под номером " << imaxel + 1 << endl;

	return 0;
}


// функция находит наибольший элемент в заданном массиве и возвращает его индекс,
// nelem — количество элементов в заданном массиве n[],
// nelem не должно быть меньше 1
int maxint(int n[], int nelem)
{
	int imax = 0; // для индекса наибольшего элемента
	              // (сначала считаем наибольшим первый элемент массива)

	// переберем элементы заданного массива, начиная со второго
	for (int i = 1; i < nelem; i++)
		if (n[imax] < n[i]) // если текущий максимальный элемент меньше i-го,
			imax = i;       // то считаем текущим максимальным i-й элемент,
	                        // иначе текущим максимальным остается тот, что и был
	return imax;
}