// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 14chapter_03exercise.cpp
// Имеется шаблон класса, представляющего очередь, который был создан в
// предыдущем упражнении (упражнение 2 главы 14). Требуется добавить в
// программу работу с исключениями, встроив их в этот шаблон класса. Речь
// идет о двух исключениях: в случае переполнения очереди и в случае попытки
// получить элемент из пустой очереди. В функции main требуется написать
// интерактивную программу, которая будет запрашивать у пользователя значения
// элементов очереди, а затем выдавать эти элементы по требованию пользователя.

// Напомню, что впервые требовалось создать класс, представляющий очередь,
// в упражнении 9 главы 7. Уже тогда я добавил в этот класс обработку двух
// ошибок, указанных выше. Затем я использовал этот класс в качестве базы
// для создания шаблона класса, представляющего очередь, в упражнении 2
// главы 14. То есть обработка требуемых ошибок в шаблоне класса уже есть,
// нужно только трансформировать ее в механизм исключений.

#include <locale>
#include <iostream>
using namespace std;

template<class T>    // шаблон класса, реализующего очередь
class queue
{
private:
	static const int MAX = 5;  // количество элементов в массиве
	                           // (одна константа для всех объектов, статическая)
	T q[MAX];                  // очередь в виде массива
	int head;                  // элемент в начале очереди
	int tail;                  // элемент в конце очереди
	int length;                // длина очереди (количество элементов в ней)
public:
	class Full                 // класс исключения
	{
	public:
		int max_num;           // максимальная вместимость очереди
		Full()                 // конструктор в классе исключения
			{ max_num = MAX; }
	};
	class Empty {};            // класс исключения
	queue()                    // конструктор
	{
		// очередь пуста
		head = 0; tail = -1;
		length = 0;
	}
	void put(T var);           // поместить в очередь
	T get();                   // взять из очереди
	void display() const;      // показать на экране содержимое очереди
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));
	// переключение стандартного потока ввода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	queue<int> q1;        // очередь с элементами типа int
	int el;               // элемент очереди типа int
	wchar_t ch;           // выбор пользователя (д/н)
	int action_num;       // номер действия с очередью

	do {

		// узнаём у пользователя, какое действие с очередью он хочет совершить
		wcout << L"Введите номер действия с очередью (1 — поместить, 2 — взять): ";
		wcin >> action_num;

		// попытка выполнить действие с очередью
		try
		{
			switch (action_num)
			{
			case 1: // поместить в очередь
				wcout << L"  Введите значение элемента: "; wcin >> el; q1.put(el);
				break;
			case 2: // взять из очереди
				wcout << L"  Значение извлеченного элемента: " << q1.get() << endl;
				break;
			default:
				wcout << L"  Неверный номер. Попробуйте ещё.\n\n"; ch = L'д'; continue;
			}
		}
		catch (queue<int>::Full err)
		{
			wcout << L"  Ошибка: очередь не может содержать больше " << err.max_num << L" элементов!\n";
			wcout << L"  Действие не выполнено.\n";
		}
		catch (queue<int>::Empty)
		{
			wcout << L"  Ошибка: вы попытались взять из пустой очереди!\n";
			wcout << L"  Действие не выполнено.\n";
		}

		// покажем содержимое очереди
		wcout << L"  Содержимое очереди: "; q1.display(); wcout << endl;

		// запрос о выходе из программы
		wcout << L"\nХотите ещё поработать с очередью? (д/н): ";
		wcin >> ch; wcout << endl;

	} while (ch == L'д'); // выход по вводу 'н' (нет)

	return 0;
}

template<class T>
void queue<T>::put(T var)      // поместить в очередь
{
	// при переполнении очереди генерируем исключение Full
	if (length == MAX)
		throw Full();

	// если перед добавлением элемента конец очереди совпадает с концом массива,
	// то перебрасываем конец очереди в начало массива
	if (tail == MAX - 1)
		tail = -1;

	q[++tail] = var; length++;
}

template<class T>
T queue<T>::get()              // взять из очереди
{
	// при попытке взять из пустой очереди генерируем исключение Empty
	if (length == 0)
		throw Empty();

	T var = q[head++]; length--;

	// если после извлечения элемента из очереди индекс начала очереди вышел
	// за конец массива, перебросим его в начало массива
	if (head == MAX)
		head = 0;

	return var;
}

template<class T>
void queue<T>::display() const // показать на экране содержимое очереди
{
	if (length == 0)
		wcout << L"пуста";

	for (int i = 0; i < length; i++)
	{
		if (head + i < MAX)
			wcout << q[head + i] << L' ';
		else
			wcout << q[head + i - MAX] << L' ';
	}
}
