// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 14chapter_10exercise.cpp
// Имеется программа из примера 549_englerr.cpp главы 12, в которой создан
// класс Distance, представляющий отрезок в английской системе мер. Метод
// getdist этого класса написан с контролем ввода данных. Проверка футов
// вынесена в отдельную вспомогательную функцию isFeet (в задании к текущему
// упражнению эта функция ошибочно упоминается как isint).
//
// Требуется добавить класс исключения в класс Distance примерно так, как
// это было сделано в примерах 668_xdist.cpp и 670_xdist2.cpp текущей (14-й)
// главы. Требуется во всех местах, где в примере 549_englerr.cpp главы 12
// показывается сообщение об ошибке, генерировать исключение. Требуется
// использовать аргумент конструктора объекта класса исключения, чтобы
// передать информацию о том, где произошла ошибка и какова причина ошибки.
// Также требуется генерировать исключение, когда ошибка произошла внутри
// функции isFeet. Требуется ответить на вопрос: может ли функция isFeet
// оставаться независимой, если она генерирует исключения? Требуется в
// функции main вставить блоки try и catch внутрь цикла, чтобы дать
// пользователю возможность исправить ошибку. Еще требуется добавить
// генерацию исключения в конструктор с двумя аргументами в классе Distance,
// чтобы среагировать на ошибку программиста при инициализации объекта
// неверным значением.
//
// В комментариях используется понятие «пробельные символы» (white space),
// которое включает пробелы, символы табуляции, символы новой строки.
////////////////////////////////////////////////////////////////////////////////

// ОТВЕТ на вопрос «может ли функция isFeet оставаться независимой, если она
// генерирует исключения?»: как можно увидеть из программы ниже, это возможно.
// Только при вызове конструктора для объекта класса исключения придется
// писать так: ИмяКласса::ИмяКонструктораИзКлассаИсключения().

// ВЫВОДЫ. Хоть программу и получилось сделать рабочей, но не вышло
// получать от пользователя данные в двух отдельных циклах — для футов и
// для дюймов, как это было в программе 549_englerr.cpp до внесения в нее
// текущих изменений. Теперь если пользователь вводит с ошибкой количество
// дюймов, то программа возвращает его к самому началу, заставляя снова вводить
// сначала количество футов, а потом опять дюймов. Чтобы сделать работу по вводу
// информации такой же, как в оригинальной программе 549_englerr.cpp, по-видимому,
// нужно разделить функцию getdist на две: getfeet и getinches, а циклы
// вынести в main. Но такая дальнейшая работа уже выходит за рамки задания
// к этому упражнению.

#include <locale>
#include <iostream>
#include <string>     // для работы с классом wstring
// #include <cstdlib> // для функций _wtoi, _wtof не понадобился
using namespace std;

int isFeet(wstring);  // предварительное объявление функции

class Distance // интервал (длина) в английской системе мер
{
private:
	int feet;     // футы (1 фут = 12 дюймов)
	float inches; // дюймы
public:
	class ExDist  // класс исключения
	{
	public:
		int num;               // номер ошибки
		ExDist(int n) : num(n) // конструктор с одним аргументом
			{ }
	};

	// конструктор без аргументов
	Distance() : feet(0), inches(0.0)
		{ }
	// конструктор с двумя аргументами
	Distance(int ft, float in)
	{
		if (ft < -999 || ft > 999)
			throw ExDist(7);
		feet = ft;
		if (in >= 12.0 || in < 0.0)
			throw ExDist(8);
		inches = in;
	}
	void showdist() const // вывод интервала на экран
		{ wcout << feet << L"\'-" << inches << L'\"'; }
	void getdist();       // метод для получения интервала у пользователя
};

// метод для получения интервала у пользователя
void Distance::getdist()
{
	wstring instr; // для входной строки

	// бесконечный цикл для проверки футов (выход — с помощью оператора break)
	while (true)
	{
		wcout << L"Введите футы: ";
		wcin.unsetf(ios::skipws);        // не пропускать пробельные символы
		wcin >> instr;                   // получить футы как строку
		// если футы введены правильно, то
		if (isFeet(instr))
		{
			wcin.ignore(10, L'\n');      // стереть оставшиеся в wcin непрочитанные символы,
			                             // включая символ новой строки
			feet = _wtoi(instr.c_str()); // преобразовать введенную пользователем и
			                             // проверенную нами строку в целое число,
			                             // это и будет число футов,
			break;                       // выйти из цикла проверки футов
		}
		// иначе: введенная строка не прошла проверку (не является целым числом)
		wcin.clear();                    // очистить биты ошибок
		                                 // (эта команда в книге в этом месте ошибочно пропущена)
		wcin.ignore(10, L'\n');          // стереть оставшиеся в wcin непрочитанные символы,
		                                 // включая символ новой строки
		throw ExDist(1);                 // генерируем исключение (вместо сообщения об ошибке)
	}

	// бесконечный цикл для проверки дюймов (выход — с помощью оператора break)
	while (true)
	{
		wcout << L"Введите дюймы: ";
		wcin.unsetf(ios::skipws);        // не пропускать пробельные символы
		wcin >> inches;                  // получить дюймы (тип float)
		// если введенное значение дюймов не попадает в правильный диапазон, то
		if (inches >= 12.0 || inches < 0.0)
		{
			throw ExDist(2);             // генерируем исключение (вместо сообщения об ошибке)
			wcin.clear(ios::failbit);    // «искусственно» установить флаг ошибки
		}
		// если пользователь ввел дюймы без ошибок (бывает, что вводят буквы вместо цифр)
		if (wcin.good())
		{
			wcin.ignore(10, L'\n');      // стереть оставшиеся в wcin непрочитанные символы,
			                             // включая символ новой строки
			break;                       // выйти из цикла проверки дюймов
		}
		// иначе: ввод ошибочен
		wcin.clear();                    // очистить биты ошибок
		wcin.ignore(10, L'\n');          // стереть оставшиеся в wcin непрочитанные символы,
		                                 // включая символ новой строки
		throw ExDist(3);                 // генерируем исключение (вместо сообщения об ошибке)
	}
}

// функция для проверки строки с числом футов, введенной пользователем
// [возвращает 1 (true), если всё введено верно, иначе — 0 (false)]
int isFeet(wstring str)
{
	int slen = str.size();         // получим длину строки
	// если ничего не введено или введено слишком много символов, то
	if (slen == 0 || slen > 5)
		throw Distance::ExDist(4); // генерируем исключение вместо возврата
		// return 0;               // завершить работу функции; возвратить false
	// проверим каждый символ строки
	for (int j = 0; j < slen; j++)
		// если не цифра и не минус, то
		if ((str[j] < L'0' || str[j] > L'9') && str[j] != L'-')
			throw Distance::ExDist(5); // генерируем исключение вместо возврата
			// return 0;           // завершить работу функции; возвратить false
	// пока всё в порядке, поэтому
	double n = _wtof(str.c_str()); // преобразуем строку в число типа double
	// если полученное число не укладывается в правильный диапазон, то
	if (n < -999.0 || n > 999.0)
		throw Distance::ExDist(6); // генерируем исключение вместо возврата
		// return 0;               // завершить работу функции; возвратить false
	// успешно пройдены все проверки, поэтому
	return 1;                      // завершить работу функции; возвратить true
}

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));
	// переключение стандартного потока ввода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	// проверка генерации исключений в конструкторе с 2 аргументами объекта
	// класса Distance

	try
	{
		Distance dst1(52, 10.54);      // всё верно
		// Distance dst2(1002, 10.54); // ошибка в количестве футов
		// Distance dst3(52, 12.54);   // ошибка в количестве дюймов
	}
	catch (Distance::ExDist err)       // обработчик исключения
	{
		switch (err.num)
		{
		case 7:
			wcout << L"констр.с 2 арг.: Кол-во футов должно быть в диапазоне -999..999\n";
			break;
		case 8:
			wcout << L"констр.с 2 арг.: Кол-во дюймов должно быть >= 0 и меньше 12\n";
			break;
		}
	}
	
	// проверка генерации исключений при вводе количества футов и дюймов
	// пользователем

	Distance d;                        // создадим объект класса Distance
	wchar_t ans;

	do
	{
		
		try
		{
			d.getdist();               // получим его значение от пользователя
		}
		catch (Distance::ExDist err)   // обработчик исключения
		{
			// в зависимости от номера ошибки выведем соответствующее сообщение
			switch (err.num)
			{
			case 1:
				wcout << L"getdist(): Футы должны быть целым числом, меньшим, чем 1000\n";
				break;
			case 2:
				wcout << L"getdist(): Дюймы должны быть между 0.0 и 11.99\n";
				wcin.clear();           // очистить биты ошибок
				wcin.ignore(10, L'\n'); // стереть оставшиеся в wcin непрочитанные символы,
										// включая символ новой строки
				break;
			case 3:
				wcout << L"getdist(): Неверно введены дюймы\n";
				break;
			case 4:
				wcout << L"isFeet(): Ничего не введено или введено слишком много символов\n";
				wcin.clear();           // очистить биты ошибок
				wcin.ignore(10, L'\n'); // стереть оставшиеся в wcin непрочитанные символы,
										// включая символ новой строки
				break;
			case 5:
				wcout << L"isFeet(): Количество футов может содержать только цифры и знак минуса\n";
				wcin.clear();           // очистить биты ошибок
				wcin.ignore(10, L'\n'); // стереть оставшиеся в wcin непрочитанные символы,
										// включая символ новой строки
				break;
			case 6:
				wcout << L"isFeet(): Количество футов должно быть в диапазоне -999..999\n";
				wcin.clear();           // очистить биты ошибок
				wcin.ignore(10, L'\n'); // стереть оставшиеся в wcin непрочитанные символы,
										// включая символ новой строки
				break;
			}
			// и начнем цикл с начала
			wcout << L"  начните ввод заново...\n";
			ans = L'д'; continue;
		}
		
		wcout << L"Интервал = ";
		d.showdist();                  // выведем его на экран
		wcout << L"\nЕщё раз (д/н)? ";
		wcin >> ans;
		wcin.ignore(10, L'\n');        // сотрём оставшиеся в wcin непрочитанные символы,
		                               // включая символ новой строки
	} while (ans != L'н');             // выход из цикла — по нажатию 'н'
	
	return 0;
}