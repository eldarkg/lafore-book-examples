// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 10chapter_06exercise.cpp
// Требуется написать свою собственную версию библиотечной функции wcscmp,
// сравнивающую две заданных строки и возвращающую результат сравнения.
// Новую функцию предлагается назвать compwcs. В main требуется написать
// программу, тестирующую написанную функцию.

// Библиотечная функция wcscmp принимает в качестве аргументов две строки,
// которые требуется сравнить, и возвращает результат в виде числа типа int.
// В случае, если первая строка меньше второй, возвращаемое число будет
// отрицательным (< 0). Если первая строка идентична второй, возвращаемое
// число будет равно нулю. Если первая строка больше второй, возвращаемое
// число будет положительным (> 0).

// Заданные строки сравниваются посимвольно. Сравнение останавливается на первом
// символе, различном для заданных строк, после чего возвращается результат.

// Если длины строк разные, а посимвольно короткая строка совпадает с длинной,
// то большей считается более длинная строка. Например, "123" < "1234",
// но "124" > "1234".

#include <locale>
#include <iostream>
using namespace std;

int compwcs(const wchar_t *, const wchar_t *); // прототип функции

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));
	// переключение стандартного потока ввода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	const wchar_t *str1, *str2; // строки для сравнения

	// При сортировке фамилий по возрастанию (то есть по алфавиту) фамилии
	// отсортируются так (фамилия выше (ближе к началу алфавита) считается меньшей):
	// 1. Petrov
	// 2. Архангельский
	// 3. Петров
	// 4. Петровский
	// 5. Сидоров
	// 6. Яковлев
	// 7. сидоров (с прописной буквы)

	str1 = L"Сидоров"; str2 = L"Петровский"; // результат: 1 (str1 > str2)
	wcout << L'"' << str1 << L"\", \"" << str2 << L"\", результат: " << compwcs(str1, str2) << endl;

	str1 = L"Петровский"; str2 = L"Сидоров"; // результат: -1 (str1 < str2)
	wcout << L'"' << str1 << L"\", \"" << str2 << L"\", результат: " << compwcs(str1, str2) << endl;

	str1 = L"Петров"; str2 = L"Петров"; // результат: 0 (str1 == str2)
	wcout << L'"' << str1 << L"\", \"" << str2 << L"\", результат: " << compwcs(str1, str2) << endl;

	str1 = L"Петров"; str2 = L"Петровский"; // результат: -1 (str1 < str2)
	wcout << L'"' << str1 << L"\", \"" << str2 << L"\", результат: " << compwcs(str1, str2) << endl;

	str1 = L"Петровcкий"; str2 = L"Петров"; // результат: 1 (str1 > str2)
	wcout << L'"' << str1 << L"\", \"" << str2 << L"\", результат: " << compwcs(str1, str2) << endl;

	// Предположим, оператор ошибся и ввел фамилию с прописной буквы: "сидоров". Такая фамилия
	// в списке станет после всех фамилий, введенных с ЗАГЛАВНОЙ буквы, так как коды
	// прописных букв в Юникоде больше, чем коды ЗАГЛАВНЫХ

	str1 = L"сидоров"; str2 = L"Яковлев"; // результат: 1 (str1 > str2)
	wcout << L'"' << str1 << L"\", \"" << str2 << L"\", результат: " << compwcs(str1, str2) << endl;

	// Предположим, оператор ввел одну из фамилий латиницей: "Petrov". В списке фамилий
	// фамилии, введенные латиницей, станут выше, чем фамилии, введенные кириллицей, так как
	// коды латинских букв в Юникоде меньше, чем коды кириллических

	str1 = L"Petrov"; str2 = L"Архангельский"; // результат: -1 (str1 < str2)
	wcout << L'"' << str1 << L"\", \"" << str2 << L"\", результат: " << compwcs(str1, str2) << endl;

	return 0;
}

// функция сравнивает две заданные строки и возвращает результат сравнения:
//  0 — строки равны;
// -1 — первая строка меньше второй;
//  1 — первая строка больше второй
int compwcs(const wchar_t *s1, const wchar_t *s2)
{
	while (*s1 && *s2)      // пока не достигнут конец ни одной из строк,
	{                       // сравниваем их посимвольно:
		if (*s1 > *s2)      // если символ первой строки больше символа второй,
			return 1;       // возвращаем 1 (первая строка больше второй)
		else if (*s1 < *s2) // если символ первой строки меньше символа второй,
			return -1;      // возвращаем -1 (первая строка меньше второй)
		s1++; s2++;         // переходим к следующему символу в каждой из строк
	}

	// если программа дошла сюда, значит был достигнут конец либо одной из строк,
	// либо конец обеих строк одновременно, при этом короткая строка полностью
	// совпадает с началом длинной

	if (!*s1 && !*s2)       // если строки равны по длине и совпадают посимвольно,
		return 0;           // возвращаем 0 (строки равны)
	else if (!*s1)          // если первая строка короче, а посимвольно строки совпадают,
		return -1;          // возвращаем -1 (первая строка меньше второй)
	else                    // если вторая строка короче, а посимвольно строки совпадают,
		return 1;           // возвращаем 1 (первая строка больше второй)
}