// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// 10chapter_12exercise.cpp
// Требуется написать два класса, моделирующих работу с переменными и указателями.

// При этом память компьютера должна моделироваться с помощью массивов.
// Тогда индекс массива будет аналогом адреса в памяти компьютера.

// Было бы ближе к действительности смоделировать память компьютера с помощью
// массива типа char (этот тип занимает 1 байт, а память настоящих компьютеров
// тоже измеряется в байтах), но мы не сможем сохранить в такой массив значения
// типа float и т.д. Поэтому память компьютера будем моделировать с помощью
// нескольких массивов, то есть для каждого типа должен быть отведен массив
// этого же типа. По условиям данного упражнения мы должны ограничиться лишь
// вещественными числами типа float, то есть для моделирования памяти под эти
// значения должен использоваться массив fmemory типа float.

// В нашей модели адрес в памяти компьютера соответствует индексу массива fmemory.
// В реальной жизни адреса переменных тоже хранятся в памяти компьютера. Наши «адреса»
// (индексы массива fmemory) имеют тип int, поэтому для моделирования части памяти
// компьютера, в которой они хранятся, будем использовать массив pmemory типа int.

#include <locale>
#include <iostream>
using namespace std;

// моделируем ту часть памяти компьютера, которая может хранить только
// вещественные числа типа float
const int fm_SIZE = 100; // размер этой части памяти (количество мест для хранения чисел)
float fmemory[fm_SIZE];  // массив, представляющий часть памяти компьютера
int fmem_top = 0;        // следующее свободное место в этой части памяти компьютера

// моделируем ту часть памяти компьютера, которая может хранить только
// адреса (адреса любых значений в памяти компьютера тоже хранятся в памяти)
const int pm_SIZE = 100; // размер этой части памяти (количество мест для хранения адресов)
int pmemory[pm_SIZE];    // массив, представляющий часть памяти компьютера
int pmem_top = 0;        // следующее свободное место в этой части памяти компьютера

class Float // класс, моделирующий переменную типа float
{
private:
	int addr; // адрес в памяти, по которому хранится значение нашей переменной
	          // (в нашей модели это индекс массива, представляющего память компьютера)
public:
	Float(float value)     // конструктор с одним аргументом
	{
		fmemory[fmem_top] = value; // сохраняем значение нашей переменной в «память»
		addr = fmem_top;           // запоминаем «адрес» нашей переменной в «памяти»
		fmem_top++;                // изменяем индекс, указывающий на следующее свободное
		                           // место в «памяти»
	}
	int operator& () const // перегрузка операции & получения адреса переменной в памяти
		{ return addr; }
};

class ptrFloat // класс, моделирующий указатель на значение типа float
{
private:
	int addr; // адрес в памяти, по которому хранится значение нашего указателя
	          // (в нашей модели это индекс массива, представляющего память компьютера)
public:
	ptrFloat(int value)      // конструктор с одним аргументом
	{
		pmemory[pmem_top] = value; // сохраняем значение нашего указателя в «память»
		addr = pmem_top;           // запоминаем «адрес» нашего указателя в «памяти»
		pmem_top++;                // изменяем индекс, указывающий на следующее свободное
		                           // место в «памяти»
	}
	float& operator* () const // перегрузка операции * разыменования указателя
		{ return fmemory[pmemory[addr]]; }
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	Float var1 = 1.234f; // объявим и инициализируем две «переменные типа Float»
	Float var2 = 5.678f;

	ptrFloat ptr1 = &var1; // объявим два «указателя на значения типа Float»
	ptrFloat ptr2 = &var2; // и инициализируем их «адресами» вышеобъявленных «переменных»
	
	wcout << L"*ptr1 = " << *ptr1 << endl; // неявно извлечём значения переменных var1 и var2
	wcout << L"*ptr2 = " << *ptr2 << endl << endl; // и покажем их на экране
	
	*ptr1 = 7.123f; // присвоим новые значения переменным,
	*ptr2 = 8.456f; // на которые указывают указатели ptr1 и ptr2

	wcout << L"*ptr1 = " << *ptr1 << endl; // неявно извлечём значения переменных var1 и var2
	wcout << L"*ptr2 = " << *ptr2 << endl; // и покажем их на экране

	return 0;
}