// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// strconv.cpp
// преобразование обычных строк (массив типа wchar_t) в объекты класса String и наоборот:
// 1) преобразование массива типа wchar_t в объект класса String выполняется в конструкторе
//    с одним параметром;
// 2) преобразование объекта класса String в массив типа wchar_t выполняется в функции
//    с заголовком operator wchar_t* ().

// для использования небезопасной функции wcscpy
#define _CRT_SECURE_NO_WARNINGS

#include <locale>
#include <iostream>
using namespace std;
// #include <string.h> // для функции wcscpy не понадобился

class String // класс, представляющий строку (массив символов)
{
private:
	// enum { SZ = 80 }; // максимальный размер строки (нестандартный синтаксис)
	static const int SZ = 80; // максимальный размер строки
							  // (одна константа для всех объектов, статическая)
	wchar_t str[SZ];          // сама строка
public:
	String() // конструктор без параметров
		{ str[0] = L'\0'; }
	String(const wchar_t s[]) // конструктор с одним параметром
	{
		wcscpy(str, s);
		// wcscpy_s(str, SZ, s); // рекомендуемый более безопасный вариант
	}
	void display() const // показ строки на экране
		{ wcout << str; }
	// преобразование объекта класса String к обычной строке (массив типа wchar_t)
	operator wchar_t* ()
		{ return str; }
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	String s1; // используем конструктор без параметров

	wchar_t xstr[] = L"Ура, товарищи! "; // создаем обычную строку

	s1 = xstr; // неявно используем конструктор с одним параметром

	s1.display(); // показываем строку

	String s2 = L"Мы победим!"; // снова используем конструктор с одним параметром

	// используем оператор преобразования типов для преобразования объекта типа String
	// в обычную строку (массив типа wchar_t)
	wcout << static_cast<wchar_t*>(s2);
	wcout << endl;

	return 0;
}