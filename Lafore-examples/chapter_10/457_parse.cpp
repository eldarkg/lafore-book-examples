// исходный текст программы сохранен в кодировке UTF-8 с сигнатурой

// parse.cpp
// программа разбора (парсинга) арифметических выражений
// (вычисляет арифметические выражения, составленные из одноцифровых чисел;
// возможные знаки операций: *, /, +, -)

#include <locale>
#include <iostream>
// #include <cstring> // для работы с функциями вроде wcslen и т.п. не понадобился
using namespace std;

const int LEN = 80; // максимальная длина арифметического выражения (в символах)
const int MAX = 40; // размер стека

class Stack // класс, реализующий стек
{
private:
	wchar_t st[MAX]; // стек в виде массива символов
	int top;         // индекс, указывающий на вершину стека
public:
	Stack()                // конструктор без аргументов
		{ top = 0; }
	void push(wchar_t var) // поместить символ в стек
		{ st[++top] = var; }
	wchar_t pop()          // забрать символ из стека
		{ return st[top--]; }
	int gettop()           // получить индекс, указывающий на вершину стека
		{ return top; }
};

class express // класс, представляющий арифметическое выражение
{
private:
	Stack s;       // стек для анализа арифметического выражения
	wchar_t* pStr; // указатель на заданную строку с арифметическим выражением
	int len;       // длина заданной строки
public:
	express(wchar_t* ptr) // конструктор с одним аргументом
	{
		pStr = ptr;         // запоминаем указатель на заданную строку
		len = wcslen(pStr); // запоминаем длину заданной строки
	}
	void parse(); // разбор (парсинг) заданной строки с арифметическим выражением
	int solve();  // вычисление арифметического выражения, оставшегося в стеке
};

// разбор (парсинг) заданной строки с арифметическим выражением
// (метод разбивает выражение на символы и добавляет их в стек, вычисляя
// добавленное в стек ранее, после чего в стеке остается простое выражение вида 5+4
// или вида 2+3*5, в котором можно произвести вычисления справа налево одним проходом,
// что и будет сделано в методе express::solve)
void express::parse()
{
	wchar_t ch;      // символ из заданной строки с арифметическим выражением
	wchar_t lastval; // последнее помещенное в стек число (операнд)
	wchar_t lastop;  // последний помещенный в стек знак операции

	for (int j = 0; j < len; j++) // переберем в цикле символы заданной строки
	{
		ch = pStr[j]; // получим очередной символ

		if (ch >= L'0' && ch <= L'9') // если это одноцифровое число,
			s.push(ch - L'0');        // то помещаем его в стек как числовую величину
		                              // (в стек помещается символ, код которого равен
		                              // нашему числу)
		                              // если это знак арифметической операции
		else if (ch == L'+' || ch == L'-' || ch == L'*' || ch == L'/')
		{
			if (s.gettop() == 1) // если это первый в выражении знак операции,
				s.push(ch);      // просто помещаем его в стек
			else // это не первый в выражении знак операции
			{
				lastval = s.pop(); // получаем предыдущее в анализе число-операнд
				lastop = s.pop();  // получаем предыдущий в анализе знак операции
				// если наш знак операции * или /, а предыдущий был + или -, то
				if ((ch == L'*' || ch == L'/') && (lastop == L'+' || lastop == L'-'))
				{
					s.push(lastop); // отменяем последние два взятия из стека
					s.push(lastval);
				}
				else // во всех других случаях
				{
					// выполним предыдущую операцию и поместим результат в стек
					switch (lastop)
					{
					case L'+': s.push(s.pop() + lastval); break;
					case L'-': s.push(s.pop() - lastval); break;
					case L'*': s.push(s.pop() * lastval); break;
					case L'/': s.push(s.pop() / lastval); break;
					default: wcout << L"\nНеизвестный знак операции"; exit(1);
					}
				}
				s.push(ch); // помещаем в стек текущий знак операции
			}
		}
		else // если символ не является ни одноцифровым числом, ни знаком операции
			{ wcout << L"\nНеразрешенный символ в арифметическом выражении"; exit(1); }
	}
}

// вычисление арифметического выражения, оставшегося в стеке
// (после чего стек остается пустым)
int express::solve()
{
	wchar_t lastval; // последнее помещенное в стек число (операнд)

	while (s.gettop() > 1) // пока в стеке не останется результат вычисления
	{                      // нашего арифметического выражения,
		lastval = s.pop(); // получим последнее в анализе число-операнд
		switch (s.pop())   // получим последний в анализе знак операции
		{                  // выполним операцию и поместим результат в стек
		case L'+': s.push(s.pop() + lastval); break;
		case L'-': s.push(s.pop() - lastval); break;
		case L'*': s.push(s.pop() * lastval); break;
		case L'/': s.push(s.pop() / lastval); break;
		default: wcout << L"\nНеизвестный знак операции"; exit(1);
		}
	}

	return int(s.pop()); // в стеке остался результат вычисления выражения,
	                     // забираем его и возвращаем; стек остается пустым
	
	// приведение к типу int необходимо потому, что при анализе в стек
	// сохраняются символы с кодами-одноцифровыми числами из заданного выражения и
	// с кодами-операндами, представляющими промежуточные вычисления;
	// поэтому мы должны возвратить не символ, а его код
}

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));
	// переключение стандартного потока ввода в формат Юникода
	locale::global(locale("ru_RU.UTF-8"));

	wchar_t ans;         // 'д' или 'н'
	wchar_t string[LEN]; // строка с арифметическим выражением для разбора (парсинга)

	wcout << L"Введите арифметическое выражение в виде 2+3*4/3-2."
	         L"\nЧисла должны быть из одной цифры."
	         L"\nНе используйте пробелы и скобки.\n";

	do {
		wcout << L"\nВведите выражение: ";
		wcin >> string;                       // получаем строку от пользователя
		express* eptr = new express(string);  // создаем объект-выражение для разбора

		eptr->parse();                        // выполняем разбор (парсинг) выражения

		wcout << L"Результат вычисления выражения: "
		      << eptr->solve();               // получаем результат вычисления

		delete eptr;                          // удаляем объект-выражение

		wcout << L"\nЕще одно выражение (д/н)? "; wcin >> ans;
	} while (ans == L'д');

	return 0;
}